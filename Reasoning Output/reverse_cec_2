

This is the derivation of the cost-equivalent evaluation context [-] xs ++ ys.
It is used in the proof of reverse assumption (B) and condition (2)

Originally introduced in Worker/Wrapper/Makes it/Faster by Hackett and Hutton.

UNIE script found in: /Improvement Scripts/reverse_cec_2


----------------------------------------------------------------------------------------------------
Transformation info: -----
----------------------------------------------------------------------------------------------------
-- Goal: -----------------
N/A
-- Global relation: ------
N/A
-- Steps: ---------------
15
-- Navigation steps: ----
6
----------------------------------------------------------------------------------------------------
Transformation history: --
----------------------------------------------------------------------------------------------------
    { trans $ ([-] xs) ++ ys $ }

([-] xs) ++ ys

  ≡ { left }

([-] xs) ++ ys

  ≡ { desugar app }

(let a = [-] xs in (++) a) ys

  ≡ { up }

(let a = [-] xs in (++) a) ys

 ≲≳ { let-eval $ [-] ys $ }

let a = [-] xs in a ++ ys

  ≡ { right }

let a = [-] xs in a ++ ys

 ≲≳ { value-beta '(++) $ [-] a ys $ }

let a = [-] xs
in ✔(λxs.λys.case xs of
              []      ➞ ys
              (z::zs) ➞ let rs = zs ++ ys in (z::rs))
   a ys

 ≲≳ { tick-eval $ [-] a ys $ }

let a = [-] xs
in ✔((λxs.λys.case xs of
               []      ➞ ys
               (z::zs) ➞ let rs = zs ++ ys in (z::rs))
     a ys)

  ≡ { right }

let a = [-] xs
in ✔((λxs.λys.case xs of
               []      ➞ ys
               (z::zs) ➞ let rs = zs ++ ys in (z::rs))
     a ys)

 ≲≳ { beta }

let a = [-] xs
in ✔((λys.case a of
           []      ➞ ys
           (z::zs) ➞ let rs = zs ++ ys in (z::rs))
     ys)

 ≲≳ { beta }

let a = [-] xs
in ✔(case a of
      []      ➞ ys
      (z::zs) ➞ let rs = zs ++ ys in (z::rs))

  ≡ { up }

let a = [-] xs
in ✔(case a of
      []      ➞ ys
      (z::zs) ➞ let rs = zs ++ ys in (z::rs))

  ≡ { desugar tick }

let a = [-] xs
in let b = case a of
            []      ➞ ys
            (z::zs) ➞ let rs = zs ++ ys in (z::rs)
   in b

  ≡ { up }

let a = [-] xs
in let b = case a of
            []      ➞ ys
            (z::zs) ➞ let rs = zs ++ ys in (z::rs)
   in b

 ≲≳ { let-flatten }

let a = [-] xs
    b = case a of
         []      ➞ ys
         (z::zs) ➞ let rs = zs ++ ys in (z::rs)
in b

----------------------------------------------------------------------------------------------------
Warning: as the global relation has not been set, the above transformation steps do not necessarily
constitute an inequational proof.


----------------------------------------------------------------------------------------------------
-- Generated by UNIE on: 18-10-2017 ----------------------------------------------------------------
